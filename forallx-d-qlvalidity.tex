\part{Validity in QL}
\label{ch.qlvalidity}
\addtocontents{toc}{\protect\mbox{}\protect\hrulefill\par}
\chapter{Part 21 Symbolizing VS Translating}
\section{Part 21.1 Extensionality}
I have often mentioned that PL is a truth-functional language. The sentence letters are, in a sense, assigned a truth value and then the connectives (being truth-functional) return a truth value as an output given the kind of input it was given. This is all we can do with PL; map sentences to particular truth values. We can do this directly; for example, we might stipulate that the PL sentence ‘P’ is to be true, which is what we did with truth tables. We can also map the sentences to truth values indirectly by offering a symbolization key and seeing whether this lines up with reality, for example:
\begin{ekey}
\item[B] Big Ben is in London
\end{ekey}
This, however, is just one of the ways in which we can give a sentence a truth value. Here, we are stipulating what we mean by B. The above symbolization key functions in the same way as this stipulation:
\factoidbox{
The PL sentence ‘B’ is true iff Big Ben is in London
}
This is an issue because there is a lot more to meaning than the truth values and PL can't tell us about the meaning beyond merely the truth values. Overlooking this, some in Linguistics believe that this is all meaning is, the conditions under which the statement is true. If meaning were just the truth conditions, then it would be impossible for us to tell the difference between necessary truths; for example, the statements "blue is a color" and "2+2=4" obviously mean radically different things but they are both always true.

QL has a similar limitation. It can tell the difference between "blue is a color" and "water is H2O", since it allows us to split up the propositions into terms, predicates, and quantifiers. This enables us to consider what is true of some particular object, or of some or all objects. But that’s it. Consider a case where two predicates are true of one, and only one, term (object or person). How could QL tell the difference between the meaning of these? Frankly, it can't. Take this example:
\begin{ekey}
\item[Px] x teaches Logic at Pierce College.
\item[Dx] x is Davis Smith
\end{ekey}
These stipulations do not carry the meaning of the English predicate across into our QL predicate. We are simply stipulating something like this:
\factoidbox{
‘Px’ and ‘x teaches Logic at Pierce College’ are to be true of exactly the same things.\\
‘Dx’ and ‘x is Davis Smith’ are true of exactly the same things.
}
So, in particular:
\factoidbox{
'Px’ is to be true of exactly those things which teach Logic at Pierce College (whatever those things might be).\\
'Dx’ is to be true of exactly those things which are named Davis Smith (whatever those things might be).
}
This is an indirect way of stipulating which things a predicate is true of. Alternatively, we can stipulate predicate extensions directly. For example, we can stipulate that ‘Px’ is to be true of Davis Smith, and Davis Smith alone. As it happens, this direct stipulation would have the same effect as the indirect stipulation, since, as of the time of writing this,  Davis, and Davis alone, teaches Logic at Pierce College. The issue is that the English predicates ‘x is Davis Smith’ and ‘x teaches Logic at Pierce College’ have very different meanings despite being true of the same things. QL simply cannot tell the difference. If we were to incorporate aspects of possibility (and impossibility) into our understanding, then it will help, but those are additions beyond the scope here.

The point is that QL does not have the resources for dealing with nuances of meaning. When we interpret QL, all we are considering is what the predicates are true of, regardless of whether we specify these things directly or indirectly. The things a predicate is true of are known as the extension of that predicate. One could, in principle, think of predicates as sets of terms and ‘Pa' is true if and only if a is a part of the set P (is a part of the extension of P). We say that QL is an extensional language because QL does not represent differences of meaning between predicates that have the same extension. This is why we speak of symbolizing English sentences in QL. It is doubtful that we are translating English into QL, for translation should preserve meaning.
\section{Part 21.2 Extensions}
We can stipulate directly what predicates are to be true of. And our stipulations can be as arbitrary as we like. For example, we could stipulate that ‘Hx’ should be true of, and only of, the following objects:
\begin{earg}
\item[]Justin Trudeau
\item[]the number $\pi$
\item[]every top-F key on every piano ever made
\end{earg}
Armed with this interpretation of ‘Hx’, suppose we now add to our symbolization key:
\begin{ekey}
\item[j] Justin Trudeau
\item[a] Angela Merkel
\item[p] the number $\pi$
\end{ekey}
Then ‘Hj’ and ‘Hp’ will both be true, on this interpretation, but ‘Ha’ will be false, since Angela Merkel was not among the stipulated objects. This process of explicit stipulation is sometimes described as stipulating the extension of a predicate. Admittedly, it is very unlikely that there is a predicate in English or any other natural language which has the same extension as ‘Hx' but this is a strength of QL not a weakness. QL can consider predicates which line up with those found in natural languages but it can also consider those which natural languages would have no need for; it is, in a sense, bigger than natural languages. Logic doesn’t care about what we humans (at a particular moment) think ‘naturally go together’; to logic, all objects are on an equal footing. If some reasoning is faulty in QL, then it will certainly be faulty in a natural language. Similarly, if some reasoning works in QL, then it will work in a natural language. 

Any well-defined collection of objects is a potential extension of a one-place predicate. The example above shows one way of stipulating the extension of ‘Hx’ by enumeration, i.e., we simply list the objects in the extension of ‘Hx’. We can also stipulate the extension, as we have also already seen, by giving an English predicate, such as ‘x teaches Logic at Pierce College or ‘x is an even integer between 3 and 9’. The latter would specify an extension consisting of, and only of, 4, 6, and 8.

As another note, there are some predicates such that either it's impossible for them to be true of anything or which aren't true of anything by chance. For example, consider the predicate in English ‘x is a round square’. It is impossible for anything to be a round square as it is a contradiction of terms. Similarly, a common example is ‘x is a unicorn'. Despite what my lovely little cousins once believed, unicorns do not exist. While unicorns are possible, in the real world, nothing is a unicorn. When a predicate is not true of anything, we say that its extension is empty. We do allow empty extensions, and we can stipulate that the extension of a ‘Hx’ is to be empty simply by not listing any members. (It may be odd to consider collections of no things, but logic is odd this way sometimes.) This is useful when we are dealing with impossible things, such as being a round-square. When an extension is empty, the predicate is not true of anything. This is useful also when considering the possible truth values for a term-predicate pair. In mathematics, more particularly Set Theory, there are empty sets, called ‘The Null Set', which are analogous to what we have here.
\section{Part 21.3 Many-Placed Predicates}
Extensions are very useful and easy to understand when we are considering one-place predicates. But there are other predicates out there; two-place, three-place, four-place\ldots  The question now is whether we can apply the same general idea behind listing the members of an extension to many-place predicates. The answer is yes, but I will admit that it is a bit messier than one-place predicates. Consider a symbolization key like:
\begin{ekey}
\item[Lxy] x loves y
\end{ekey}
Previously, we have noted that this symbolization key should be read as saying:
\begin{center}
‘Lxy’ and ‘x loves y’ are to be true of exactly the same things
\end{center}
So, in particular]
\begin{center}
‘Lxy’ is to be true of x and y (in that order) iff x loves y.
\end{center}
There are some predicates which could be always symmetric, meaning that if Rab then Rba, but there are many which are not like that. For example, Betty being taller than Sam does not imply that Sam is taller than Betty. So, it is important that we insist upon the order here, since love— famously—is not always reciprocated. (Note that ‘x’ and ‘y’ on the right here are symbols of augmented English, and that they are being used. By contrast, ‘x’ and ‘y’ in ‘Lxy’ are symbols of QL, and they are being mentioned.)

As with one-place predicates, this is an indirect stipulation. This can work some of the times but we are limited to the relations which seem natural in natural language. We can also directly stipulate the extension of the many-place predicate but it is a bit tricky. If we simply list objects that fall under ‘Lxy’, we will not know whether they are the lover or the beloved (or both). We have to find a way to include the order in our explicit stipulation. To do this, we can specify that two-place predicates are true of pairs of objects, where the order of the pair is important. Thus we might stipulate that ‘Bxy’ is to be true of, and only of, the following pairs of objects:
\begin{earg}
\item[]$\openntuple$Lenin, Marx$\closentuple$
\item[]$\openntuple$de Beauvoir, Sartre$\closentuple$
\item[]$\openntuple$Sartre, de Beauvoir$\closentuple$
\end{earg}
Here the angle-brackets keep us informed concerning order. The angle brackets are used in elementary Set Theory for ordered sets while ‘curly brackets' (‘\{',‘\}') are used for sets where the order does not matter. For example, \{Max,Sally\} is the same set as \{Sally,Max\} but when order matters, the angle brackets are used. Suppose we now add the following stipulations]
\begin{ekey}
\item[l] Lenin
\item[m] Marx
\item[b] de Beauvoir
\item[r] Sartre
\end{ekey}
Then ‘Blm’ will be true, since $\openntuple$Lenin, Marx$\closentuple$ is in our explicit list, but ‘Bml’ will be false, since $\openntuple$Marx, Lenin$\closentuple$ is not in our list. However, both ‘Bbr’ and ‘Brb’ will be true, since both $\openntuple$de Beauvoir, Sartre$\closentuple$ and $\openntuple$Sartre, de Beauvoir$\closentuple$ are in our explicit list. To make these ideas more precise, we would need to develop some very elementary set theory. Set theory has formal apparatus which allows us to deal with extensions, ordered pairs, and so forth. However, set theory is not covered in this class. So I shall leave these ideas at an imprecise level. Nevertheless, the general idea should be clear.

This way of doing things might, at first brush, seem unduly complicated, but we are simply giving a written outline of something which you do every day already. If you are driving down the road and a car speeds by you, you will automatically add ‘that car' to the set of things going faster than you and, implicitly, add <that car, you> to the ‘x is going faster than y'. Similarly, when watching a soap-opera or a telenovela, you keep track of who is having what relation to whom, whether they know it, and so on. Naturally defining the extensions of various predicates. A personal favorite of mine is Twelfth Night; or what you will by William Shakespeare. Here are some of the two-place predicates which appear in the play (indirectly stipulated):
\begin{ekey}
\item[Lxy] x loves y
\item[Hxy] x hates y
\item[Bxy] x believes y is dead
\item[Pxy] x is pretending to be y
\item[Txy] x is a twin sibling of y
\end{ekey}
And here are the extensions of these predicates directly stipulated: 
\begin{ekey}
\item[Lxy] $\openntuple$Viola,Orsine$\closentuple$, $\openntuple$Orsine,Olivia$\closentuple$,$\openntuple$Olivia,Viola$\closentuple$, $\openntuple$Maria,Toby$\closentuple$,\\$\openntuple$Aguecheek,Olivia$\closentuple$,$\openntuple$Malvolio,Olivia$\closentuple$,$\openntuple$Antonio,Sebastian$\closentuple$
\item[Hxy] $\openntuple$Maria,Malvolio$\closentuple$,$\openntuple$Toby,Malvolio$\closentuple$,$\openntuple$Aguecheek,Malvolio$\closentuple$,\\$\openntuple$Feste,Malvolio$\closentuple$,$\openntuple$Aguecheek,Viola$\closentuple$,$\openntuple$Orsine,Antonio$\closentuple$
\item[Bxy] $\openntuple$Viola,Sebastian$\closentuple$,$\openntuple$Sebastian,Viola$\closentuple$
\item[Pxy] $\openntuple$Viola,Sebastian$\closentuple$,$\openntuple$Feste,the priest$\closentuple$
\item[Txy] $\openntuple$Viola,Sebastian$\closentuple$,$\openntuple$Sebastian,Viola$\closentuple$
\end{ekey}
And there are many more aside. As you watch the play, you keep track of the relations between the characters and eventually it becomes clear how the humorous events will unfold.
\section{Part 21.4 Interpretations}
We defined a valuation in PL as any assignment of truth and falsity to sentence letters. We could list out all of the possible assignments of truth and falsity with a truth table. QL, sadly, does not have the equivalent of a truth table where we could list out all of the possible assignments of truth and falsity. Rather, we need to assign the truth and falsity of our name-predicate pairs though interpretations. Interpretations consist of four (4) things:
\factoidbox{
\begin{enumerate}
\item A specific domain
\item An assignment of a truth value for each sentence letter we wish to consider. 
\item An assignment of a name to exactly one object within the domain (multiple names can be assigned the same object).
\item For each predicate that we care to consider (apart from ‘=’), a specification of what things (in what order) the predicate is to be true of. (We will be covering ‘=', called ‘identity' in the future, it acts both as a two-place predicate and as a connective.)
\end{enumerate}}
The symbolization keys that we considered previously consequently give us one very convenient way to present an interpretation. We will continue to use them in this module. The previous discussion allows us to also allow extensions specified by enumerations on the right side, for example:
\begin{ekey}
\item[domain] heads of state, numbers
\item[Hx] Justin Trudeau, Angela Merkel, $\pi$
\end{ekey}
This is a perfectly good way of specifying an interpretation. Suppose that we assigned the name j to Justin Trudeau. Using the above interpretation, Hj would be true because Trudeau is within the extension of Hx. For another example,
\begin{ekey}
\item[domain] 0, 1, 2
\item[Lxy] $\openntuple$0,1$\closentuple$, $\openntuple$0, 2$\closentuple$, $\openntuple$1, 2$\closentuple$
\end{ekey}
Here, the predicate Lxy could be understood as symbolizing "x is less than y". If we assigned the names o to 1 and t to two, in this interpretation Lot would be true because $\openntuple$1, 2$\closentuple$ is a part of the extension of Lxy. Sometimes, however, it can be rather bothersome to list out all of the elements in an extension, so we can specify the extension by defining it in the same way as in a symbolization key; in this case, by giving the English predicate ‘ x is less than y ’.

Other times, it can be convenient to give the interpretation as a diagram (making diagrams like these are very useful in illustrating Modal Logics). To illustrate (literally): suppose we want to consider just a single two-place predicate, ‘Rxy’. Then we can represent it just by drawing an arrow between two objects, and stipulate that ‘Rxy’ is to hold of x and y just in case there is an arrow running from x to y in our diagram. As an example, we might offer:
\begin{center}
	\begin{tikzpicture}[modal]
		\node[world] (w1) {1};
		\node[world] (w2) [right=of w1]{2};
		\node[world] (w3) [below=of w2]{3};
		\node[world] (w4) [below=of w1]{4};
		\path[->] (w1) edge (w2);
		\path[->] (w1) edge (w3);
		\path[->] (w2) edge (w3);
		\path[->] (w3) edge (w4);
		\path[->] (w4) edge (w1);
	\end{tikzpicture}
\end{center}
This diagram could be used to describe an interpretation whose domain is the first four positive whole numbers, and which interprets ‘Rxy’ as being true of and only of:
\begin{center}
$\openntuple$1, 2$\closentuple$, $\openntuple$2, 3$\closentuple$, $\openntuple$3, 4$\closentuple$, $\openntuple$4, 1$\closentuple$,$\openntuple$1, 3$\closentuple$
\end{center}
Equally we might offer this diagram:
\begin{center}
	\begin{tikzpicture}[modal]
		\node[world] (w1) {1};
		\node[world] (w2) [right=of w1]{2};
		\node[world] (w3) [below=of w2]{3};
		\node[world] (w4) [below=of w1]{4};
		\path[->] (w1) edge[reflexive left] (w1);
		\path[<->] (w1) edge (w3);
		\path[->] (w3) edge[reflexive right] (w3);
		\path[->] (w3) edge (w4);
	\end{tikzpicture}
\end{center}

The interpretation specified by this diagram can also be given by listing what’s in the domain and in the extension of ‘Rxy’:
\begin{ekey}
\item[domain] 1, 2, 3, 4
\item[Rxy] $\openntuple$1, 3$\closentuple$, $\openntuple$3, 1$\closentuple$, $\openntuple$3, 4$\closentuple$, $\openntuple$1, 1$\closentuple$, $\openntuple$3, 3$\closentuple$
\end{ekey}
If we wanted, we could make our diagrams more complex. For example, we could add names as labels for particular objects. Equally, to symbolize the extension of a one-place predicate, we might simply draw a circle around some particular objects and stipulate that the thus encircled objects (and only them) are to fall under the predicate ‘Hx’, say. To specify multiple predicates, we could use colored (or dashed, dotted) lines for the arrows and circles or simply label them. For example, previously, I gave an example from the play \emph{Twelfth Night}, which was directly stipulated like so:

\begin{ekey}
\item[Lxy] $\openntuple$Viola,Orsine$\closentuple$, $\openntuple$Orsine,Olivia$\closentuple$,$\openntuple$Olivia,Viola$\closentuple$, $\openntuple$Maria,Toby$\closentuple$,\\$\openntuple$Aguecheek,Olivia$\closentuple$,$\openntuple$Malvolio,Olivia$\closentuple$,$\openntuple$Antonio,Sebastian$\closentuple$

\item[Hxy] $\openntuple$Maria,Malvolio$\closentuple$,$\openntuple$Toby,Malvolio$\closentuple$,$\openntuple$Aguecheek,Malvolio$\closentuple$,\\$\openntuple$Feste,Malvolio$\closentuple$,$\openntuple$Aguecheek,Viola$\closentuple$,$\openntuple$Orsine,Antonio$\closentuple$

\item[Bxy] $\openntuple$Viola,Sebastian$\closentuple$,$\openntuple$Sebastian,Viola$\closentuple$
\item[Pxy] $\openntuple$Viola,Sebastian$\closentuple$,$\openntuple$Feste,the priest$\closentuple$
\item[Txy] $\openntuple$Viola,Sebastian$\closentuple$,$\openntuple$Sebastian,Viola$\closentuple$
\end{ekey}

We can represent this as a diagram, using L, H, B, P, and T as the labels for the arrows representing those relations, like so:

\begin{center}
	\begin{tikzpicture}[modal]
		\node[world] (olivia) {Olivia};
		\node[world] (orsine) [above right=of olivia]{Orsine};
		\node[world] (malvolio) [below=of olivia]{Malvolio}; 
		\node[world] (antonio) [right=of orsine]{Antonio}; 
		\node[world] (sebastian) [below=of antonio]{Sebastian}; 
		\node[world] (viola) [left=of sebastian]{Viola};
		\node[world] (feste) [below=of malvolio]{Feste};
		\node[world] (priest) [left=of feste]{The Priest};
		\node[world] (aguecheek) [below=of viola,xshift=5mm,yshift=-5mm]{Aguecheek}; 
		
		\node[world] (maria) [left=of olivia]{Maria};
		\node[world] (toby) [left=of malvolio]{Toby}; 

	\begin{scope}[every node/.style={fill=white,rectangle,draw}]
		\path[->] (viola) edge node[xshift=2mm] {L} (orsine);
		\path[->] (orsine) edge node[xshift=-3mm,yshift=2mm] {L} (olivia);
		\path[->] (olivia) edge node[xshift=-3mm,yshift=-2mm] {L} (viola);
		\path[->] (maria) edge node[xshift=-2mm] {L} (toby);
		\path[->] (aguecheek) edge node[xshift=3mm] {L} (olivia);
		\path[->] (malvolio) edge node[xshift=2mm] {L} (olivia);
		\path[->] (antonio) edge node[xshift=-2mm] {L} (sebastian);
		\path[->] (maria) edge node[xshift=-4mm] {H} (malvolio);
		\path[->] (toby) edge node[yshift=-2mm] {H} (malvolio);
		\path[->] (aguecheek) edge node[xshift=3mm,yshift=2mm] {H} (malvolio);
		\path[->] (feste) edge node[xshift=2.5mm] {H} (malvolio);
		\path[->] (aguecheek) edge node[xshift=3mm] {H} (viola);
		\path[->] (orsine) edge node[yshift=-2mm] {H} (antonio);
		\path[->] (feste) edge node[yshift=2mm] {P} (priest);
		\path[->] (viola) edge node[yshift=-2mm] {P} (sebastian);
		\path[<->] (viola) edge[bend left=60] node[yshift=-2mm,xshift=2mm] {T} (sebastian);
		\path[<->] (viola) edge[bend right=60] node[yshift=-2mm,xshift=-2mm] {B} (sebastian);
	\end{scope}
	\end{tikzpicture}
\end{center}
 
 

\subsection{Relational Predicates and `The Knowledge Graph'}

If you go on to Google and search for a person, place or thing, you might notice that some information about them will appear on the page without you ever needing to leave Google. For example, I could seach for Ibn Sina. On my computer, to the right hand side, there is a section which says ``About'' and then lists some general information about Ibn Sina. You might ask yourself how could a computer `know' stuff about Ibn Sina and connect this information to a fairly basic search? Google, in particular, uses `The Knowledge Graph', a term which they patented but other information databases, like Wikipedia, use the same sort of structure to arrange their data and make it user friendly. The general structure of these knowledge graphs is identical to the diagrams/interpretations which we are using for the semantics of relational predicates. Continuing with the example using Ibn Sina, when I searched for him, the `About' section had information regarding the date/place of this birth, the date/place of his death, his spouse, his parents, his full name, and the place of his burial. By searching for Ibn Sina, I triggered Google to locate the name in their knowledge graph and then follow the different relations (the arrows, called `edges') which it has to other points (called `nodes') in the graph. The section of their knowledge graph triggered might look something like this:

\begin{center}
	\begin{tikzpicture}[modal]
		\node[world] (ibn) {Ibn Sina};
		\node[world] (w2) [above=of ibn]{August 980CE};
		\node[world] (w3) [below right=of ibn,xshift=5mm]{June 22,1037};
		\node[world] (w4) [left=of ibn,xshift=-1cm]{Yasamin};
		\node[world] (w5) [above right=of ibn]{Abdullah}; 
		\node[world] (w6) [right=of ibn,xshift=1cm]{Setareh}; 
		\node[world] (w7) [below=of ibn]{Hamedan, Iran}; 
		\node[world] (w8) [above left=of ibn]{\tiny Afshona, Uzbekistan}; 
		\node[world] (w9) [below left=of ibn,xshift=-1cm,yshift=4mm]{\includegraphics[width=1.5cm]{assets/sina.jpeg}}; 
	\begin{scope}[every node/.style={fill=white,rectangle,draw}]
		\path[->] (ibn) edge node[xshift=8mm,yshift=3mm] {was born on} (w2);
		\path[<->] (ibn) edge node[yshift=3mm] {was spouse of} (w4);
		\path[->] (ibn) edge node[xshift=-6mm,yshift=-3mm] {died on} (w3);
		\path[->] (ibn) edge node[xshift=9mm,yshift=-2mm] {was child of} (w5);
		\path[->] (ibn) edge node[yshift=-2mm] {was child of} (w6);
		\path[->] (ibn) edge node[xshift=-6mm] {died in} (w7);
		\path[->] (ibn) edge node[xshift=8mm,yshift=2mm] {was born in} (w8);
		\path[->] (ibn) edge node[xshift=-8mm,yshift=3mm] {has picture} (w9);
	\end{scope}
	\end{tikzpicture}
\end{center}

You might notice that I labeled the `edges' (arrows) in this graph (diagram). This is because we are dealing with multiple different relations between the `nodes'. These `nodes' all link together with relations and Google then presents these relational predicates to you in an understandable way. There is an entire field in Computer Science which deals with the relations between data and how to organize it into these sorts of structures, confusingly called `Ontology' (Philosophy also has a field named that, dealing with the question `what exists?'). These data structures and organizations, fundamentally, reduce to constructing interpretations for a particular domain (namely, the relevant data/information in the computer system).   

\chapter{Part 22 Truth in QL}
We have introduced you to interpretations. Since, among other things, they tell us which predicates are true of which objects, they will provide us with an account of the truth of atomic sentences. However, we now need to say, precisely, what it is for an arbitrary QL sentence to be true or false in an interpretation. We know from the previous content that there are three kinds of sentence in QL:
\begin{ebullet}
\item[\textbullet]atomic sentences
\item[\textbullet]sentences whose main logical operator is a sentential connective 
\item[\textbullet]sentences whose main logical operator is a quantifier
\end{ebullet}
We need to explain truth for all three kinds of sentence. We will provide a completely general explanation in this section. For some spoilers, atomic sentences are handled similarly to PL, connectives are almost identical to PL, and quantifiers are a bit finicky.  Throughout this section, we will be using the following interpretation/symbolization key for the examples. You should keep these in mind so that you can best understand why somethings work and others do not. 
\begin{ekey}
\item[domain] all people born before 2000ce
\item[a] Aristotle
\item[b] Beyoncé
\item[Px] x is a philosopher
\item[Rxy] x was born before y
\end{ekey}
\section{Part 22.1 Atomic Sentences}
The truth of atomic sentences should be fairly straightforward. For sentence letters, the interpretation specifies if it is true or false. The sentence ‘Pa’ should be true just in case ‘Px’ is true of ‘a’. Given our go-to interpretation, this is true iff Aristotle is a philosopher. Aristotle is a philosopher. So the sentence is true. Equally, ‘Pb’ is false on our go-to interpretation. Likewise, on this interpretation, ‘Rab’ is true iff the object named by ‘a’ was born before the object named by ‘b’. Well, Aristotle was born before Beyoncé. So ‘Rab’ is true. Equally, ‘Raa’ is false: Aristotle was not born before Aristotle.

Dealing with atomic sentences, then, is very intuitive. 
\factoidbox{
When R is a one-place predicate and a is a name, the sentence Ra is true in an interpretation IFF R is true of the object named by a.\\ 
When R is an n-place predicate and $a_1, a_2, \ldots , a_n$ are names, the sentence R$a_{1}a_{2}\ldots a_{n}$ is true in an interpretation iff R is true of the objects named by $a_1, a_2, \ldots , a_n$ (in that order) in that interpretation.}
\section{Part 22.2 Connectives}
Remember that QL sentences can be built up from simpler ones using the truth-functional connectives that were familiar from PL. The rules governing these truth-functional connectives are exactly the same as they were when we considered PL. Here they are:
\factoidbox{
\metav{A}\eand \metav{B} is true in an interpretation iff both \metav{A} is true and \metav{B} is true in that interpretation\\
\metav{A}\eor \metav{B} is true in an interpretation iff either \metav{A} is true or \metav{B} is true in that interpretation\\
\enot \metav{A} is true in an interpretation iff \metav{A} is false in that interpretation\\
\metav{A}\eif \metav{B} is true in an interpretation iff either \metav{A} is false or \metav{B} is true in that interpretation\\
\metav{A}\eiff \metav{B} is true in an interpretation iff A has the same truth value as B in that interpretation\\
}
This presents the very same information as the characteristic truth tables for the connectives; it just does so in a slightly different way. As an added note, you need to be extra careful to make sure that the connective is the main operator. This was easy enough in PL because we only had sentence letters and connectives. In QL, however, we also have quantifiers, which we will cover next. If a quantifier is the main operator, then you must work through it first before you can handle the connectives. Some examples will probably help to illustrate the idea. (Make sure you understand them!) On our go-to interpretation:
\factoidbox{
 ‘Rab\eand Pa’ is true\\
‘Rab\eand Pb’ is false because, although ‘Rab’ is true, ‘Pb’ is false\\
‘Pb\eor Pa’ is true\\
‘Pa\eand \enot (Rba\eand Rab)’ is true, because ‘Pa’ is true and ‘Rba' is false\\
}
Make sure you understand these examples.
\section{Part 22.3 Quantifiers}
The exciting innovation in QL, though, is the use of quantifiers, but expressing the truth conditions for quantified sentences is a bit more fiddly than one might first expect. We will go through three different ways in which one could understand the truth conditions for quantifiers (the third being the correct one). 

\subsection{The First Way to Think About Them}

Here is a naïve first thought. We want to say that ‘$\forall$x Fx’ is true iff ‘Fx’ is true of everything in the domain. This should not be too problematic: our interpretation will specify directly what ‘Fx’ is true of.

Unfortunately, this naïve thought is not general enough. For example, we want to be able to say that ‘$\forall$x$\exists$y Lxy’ is true just in case (speaking roughly) ‘$\exists$y Lxy’ is true of everything in the domain. But our interpretation does not directly specify what ‘$\exists$y Lxy’ is true of. Instead, whether or not this is true of something should follow just from the interpretation of the predicate ‘L’, the domain, and the meanings of the quantifiers.

\subsection{The Second Way}

So here is a second naïve thought. We might try to say that ‘$\forall$x$\exists$y Lxy’ is to be true in an interpretation iff $\exists$y Lay is true for every name a that we have included in our interpretation. Similarly, we might try to say that $\exists$y Lay is true just in case Lab is true for some name b that we have included in our interpretation.

Unfortunately, this is not right either. To see this, observe that our go-to interpretation only interprets two names, ‘a’ and ‘b’. But the domain—all people born before the year 2000ce— contains many more than two people. (And we have no intention of trying to correct for this by naming all of them!)

\subsection{The Correct Way}

Although it is not the case that we have named everyone, each person could have been given a name. So we should focus on this possibility of extending an interpretation by adding a new name. We will offer a few examples of how this might work, centering on our go-to interpretation, and we will then present the formal definition.

In our go-to interpretation, ‘$\exists$x Rbx’ should be true. After all, in the domain, there is certainly someone who was born after Beyoncé. Lady Gaga is one of those people. Indeed, if we were to extend our go-to interpretation—temporarily, mind—by adding the name ‘c’ to refer to Lady Gaga, then ‘Rbc’ would be true on this extended interpretation. This, surely, should suffice to make ‘$\exists$x Rbx’ true on the original go-to interpretation.

In our go-to interpretation, ‘$\exists$x (Px\eand Rxa)’ should also be true. After all, in the domain, there is certainly someone who was both a philosopher and born before Aristotle. Socrates is one such person. Indeed, if we were to extend our go-to interpretation by letting a new name, ‘c’, denote Socrates, then ‘Wc\eand Rca’ would be true on this extended interpretation. Again, this should surely suffice to make ‘$\exists$x (Px\eand Rxa)’ true on the original go-to interpretation.

In our go-to interpretation, ‘$\forall$x$\exists$y Rxy’ should be false. After all, consider the last person born in the year 1999. We don’t know who that was, but if we were to extend our go-to interpretation by letting a new name, ‘d’, denote that person, then we would not be able to find anyone else in the domain to denote with some further new name, perhaps ‘e’, in such a way that ‘Rde’ would be true. Indeed, no matter whom we named with ‘e’, ‘Rde’ would be false. This observation is surely sufficient to make ‘$\exists$y Rdy’ false in our extended interpretation, which in turn is surely sufficient to make ‘$\forall$x$\exists$y Rxy’ false on the original go-to interpretation.

If you have understood these three examples, that’s what matters. It provides the basis for a formal definition of truth for quantified sentences. Strictly speaking, though, we still need to give that definition. The result, sadly, is a bit ugly, and requires a few new definitions. Brace yourself!

Suppose that A is a formula containing at least one occurrence of the variable x, and that x is free in A. We will write this thus:
\begin{center}
A\ldots x\ldots x\ldots 
\end{center}
Suppose also that c is a name. Then we will write:
\begin{center}
A\ldots c\ldots c\ldots 
\end{center}
for the formula we obtain by replacing every occurrence of x in A with c. The resulting formula is called a substitution instance of $\forall$xA and $\exists$xA. Also, c is called the instantiating name. So:
\begin{center}
$\exists$x (Rex\eiff Fx)
\end{center}
is a substitution instance of
\begin{center}
$\forall$y$\exists$x (Ryx\eiff Fx)
\end{center}
with the instantiating name ‘e’ and instantiated variable ‘y’.

Our interpretation will include a specification of which names correspond to which objects in the domain. Take any object in the domain, say, d, and a name c which is not already assigned by the interpretation. If our interpretation is I, then we can consider the interpretation I[d/c] which is just like I except it also assigns the name c to the object d. Then we can say that d satisfies the formula A\ldots x\ldots x\ldots  in the interpretation I if and only if A\ldots c\ldots c\ldots  is true in I[d/c]. (If d satisfies A\ldots x\ldots x\ldots  we also say that A\ldots x\ldots x\ldots  is true of d.)

The interpretation I[d/c] is just like the interpretation I except it also assigns the name c to the object d.
An object d satisfies A\ldots x\ldots x\ldots  in interpretation I iff A\ldots c\ldots c\ldots  is true in I[d/c].

So, for instance, Socrates satisfies the formula Px since Pc is true in the interpretation I[Socrates/c], i.e., the interpretation:
\begin{ekey}
\item[domain] all people born before 2000ce
\item[a] Aristotle
\item[b] Beyoncé
\item[c] Socrates
\item[Px] x is a philosopher
\item[Rxy] x was born before y
\end{ekey}
Armed with this notation, the rough idea is as follows. The sentence $\forall$xA\ldots x\ldots x\ldots  will be true in I iff, for any object d in the domain, A\ldots c\ldots c\ldots  is true in I[d/c], i.e., no matter what object (in the domain) we name with c. In other words, $\forall$xA\ldots x\ldots x\ldots  is true iff every object in the domain satisfies A\ldots x\ldots x\ldots  Similarly, the sentence $\exists$xA will be true iff there is some object that satisfies A\ldots x\ldots x\ldots , i.e., A\ldots c\ldots c\ldots  true in I[d/c] for some object d.
\factoidbox{
$\forall$xA\ldots x\ldots x\ldots  is true in an interpretation iff every object in the domain satisfies A\ldots x\ldots x\ldots \\
$\exists$xA\ldots x\ldots x\ldots  is true in an interpretation iff at least one object in the domain satisfies A\ldots x\ldots x\ldots 
}
To be clear: all this is doing is formalizing (very pedantically) the intuitive idea expressed on the previous page. The result is a bit ugly, and the final definition might look a bit opaque. Hopefully, though, the spirit of the idea is clear.

\ockham

\practiceproblems
\problempart
\label{pr.TorF1}
Consider the following interpretation:
	\begin{ebullet}
		\item The domain comprises only Corwin and Benedict
		\item `$\atom{A}{x}$' is to be true of both Corwin and Benedict
		\item `$\atom{B}{x}$' is to be true of Benedict only
		\item `$\atom{N}{x}$' is to be true of no one
		\item `$c$' is to refer to Corwin
	\end{ebullet}
Determine whether each of the following sentences is true or false in that interpretation:
\begin{enumerate}
\item $\atom{B}{c} $
\item $\atom{A}{c}  \eiff \enot \atom{N}{c}$
\item $\atom{N}{c}  \eif (\atom{A}{c} \eor \atom{B}{c})$
\item $\forall x\, \atom{A}{x}$
\item $\forall x \enot \atom{B}{x}$
\item $\exists x(\atom{A}{x} \eand \atom{B}{x})$
\item $\exists x(\atom{A}{x} \eif \atom{N}{x})$
\item $\forall x(\atom{N}{x} \eor \enot \atom{N}{x})$
\item $\exists x\, \atom{B}{x} \eif \forall x\, \atom{A}{x}$
\end{enumerate}

\problempart
\label{pr.TorF2}
Consider the following interpretation:	
	\begin{ebullet}
		\item The domain comprises only Lemmy, Courtney and Eddy
		\item `$\atom{G}{x}$' is to be true of Lemmy, Courtney and Eddy.
		\item `$\atom{H}{x}$' is to be true of and only of Courtney
		\item `$\atom{M}{x}$' is to be true of and only of Lemmy and Eddy
		\item `$c$' is to refer to Courtney
		\item `$e$' is to refer to Eddy
	\end{ebullet}
Determine whether each of the following sentences is true or false in that interpretation:
\begin{enumerate}
\item $\atom{H}{c} $
\item $\atom{H}{e} $
\item $\atom{M}{c}  \eor \atom{M}{e}$
\item $\atom{G}{c}  \eor \enot \atom{G}{c}$
\item $\atom{M}{c}  \eif \atom{G}{c}$
\item $\exists x\, \atom{H}{x}$
\item $\forall x\, \atom{H}{x}$
\item $\exists x\, \enot \atom{M}{x}$
\item $\exists x(\atom{H}{x} \eand \atom{G}{x})$
\item $\exists x(\atom{M}{x} \eand \atom{G}{x})$
\item $\forall x(\atom{H}{x} \eor \atom{M}{x})$
\item $\exists x\, \atom{H}{x} \eand \exists x\, \atom{M}{x}$
\item $\forall x(\atom{H}{x} \eiff \enot \atom{M}{x})$
\item $\exists x\, \atom{G}{x} \eand \exists x \enot \atom{G}{x}$
\item $\forall x\exists y(\atom{G}{x} \eand \atom{H}{y})$
\end{enumerate}

\chapter{Part 23 Semantic Concepts and Validity}
\section{Part 23.1: Semantic Concepts}
Defining truth in QL was quite fiddly. But now that we are done, we can define various other central logical notions. These definitions will look very similar to those for PL, from Part 9. However, remember that they concern interpretations, rather than valuations. We will use the symbol ‘$\entails$’ for QL much as we did for PL. So:
\begin{center}
$A_1,A_2,\ldots,A_n$ $\entails$ C
\end{center}
means that there is no interpretation in which all of $A_1,A_2,\ldots,A_n$ are true and in which C is false. Derivatively,
\begin{center}
$\entails$ A
\end{center}
means that A is true in every interpretation, which is the same as saying that it can be proved from nothing. The other logical notions also have corresponding definitions in QL:
\factoidbox{\begin{ebullet}
\item[\textbullet] A QL sentence A is a tautology iff A is true in every interpretation; i.e., $\entails$ A. On the other hand, A is a contradiction iff A is false in every interpretation; i.e., $\entails$ \enot A.
\item[\textbullet] $A_1,A_2,\ldots,A_n$ \therefore C is valid in QL iff there is no interpretation in which all of the premises are true and the conclusion is false; i.e., $A_1,A_2,\ldots,A_n$ $\entails$ C. It is invalid in QL otherwise.
\item[\textbullet] Two QL sentences A and B are equivalent iff they are true in exactly the same interpretations as each other; i.e., both A $\entails$ B and B $\entails$ A.
\item[\textbullet] The QL sentences $A_1,A_2,\ldots,A_n$ are jointly satisfiable iff some interpretation makes all of them true. They are jointly unsatisfiable iff there is no such interpretation.
\end{ebullet}}
\section{Part 23.2 Using Interpretations}
\subsection{Tautologies and contradictions}

Suppose we want to show that ‘$\exists$x Axx\eif Bd’ is not a tautology. This requires showing that the sentence is not true in every interpretation; i.e., that it is false in some interpretation. If we can provide just one interpretation in which the sentence is false, then we will have shown that the sentence is not a tautology.

In order for ‘$\exists$x Axx\eif Bd’ to be false, the antecedent (‘$\exists$x Axx’) must be true, and the consequent (‘Bd’) must be false. To construct such an interpretation, we start by specifying a domain. Keeping the domain small makes it easier to specify what the predicates will be true of, so we will start with a domain that has just one member. For concreteness, let’s say it is just the city of Paris.

\begin{ekey}\item[domain]  Paris
\end{ekey}
From here, we will need to have some name, let's use ‘d’ and we have no option but:

\begin{ekey}\item[domain]  Paris
\item[d] Paris
\end{ekey}
Recall that we want ‘$\exists$x Axx’ to be true, so we want all members of the domain to be paired with themselves in the extension of ‘A’. We can just offer:

\begin{ekey}\item[domain]  Paris
\item[d] Paris
\item[Axy] x is identical with y
\end{ekey}
Now ‘Add’ is true, so it is surely true that ‘$\exists$x Axx’. Next, we want ‘Bd’ to be false, so the referent of ‘d’ must not be in the extension of ‘B’. We might simply offer:

\begin{ekey}\item[domain]  Paris
\item[d] Paris
\item[Axy] x is identical with y
\item[Bx] x is in Germany
\end{ekey}
Now we have an interpretation where ‘$\exists$x Axx’ is true, but where ‘Bd’ is false. So there is an interpretation where ‘$\exists$x Axx\eif Bd’ is false. So ‘$\exists$x Axx\eif Bd’ is not a tautology.

We can just as easily show that ‘$\exists$xAxx\eif Bd’ is not a contradiction. We need only specify an interpretation in which ‘$\exists$xA(x,x) \eif B(d)’ is true; i.e., an interpretation in which either ‘$\exists$x Axx’ is false or ‘Bd’ is true. Here is one:

\begin{ekey}\item[domain]  Paris
\item[d] Paris
\item[Axy] x is identical with y
\item[Bx] x is in France
\end{ekey}
This shows that there is an interpretation where ‘$\exists$xAxx\eif Bd’ is true. So ‘$\exists$x Axx\eif Bd’ is not a contradiction. For the conditions put exactly:
\factoidbox{
To show that A is not a tautology, it suffices to find an interpretation where A is false.\\
To show that A is not a contradiction, it suffices to find an interpretation where A is true.}
\subsection{Logical equivalence}

Suppose we want to show that ‘$\forall$x Sx’ and ‘$\exists$x Sx’ are not logically equivalent. We need to construct an interpretation in which the two sentences have different truth values; we want one of them to be true and the other to be false. We start by specifying a domain. Again, we make the domain small so that we can specify extensions easily. In this case, we will need at least two objects. (If we chose a domain with only one member, the two sentences would end up with the same truth value. In order to see why, try constructing some partial interpretations with one member domains.) For concreteness, let’s take:

\begin{ekey}\item[domain]  Ornette Coleman, Miles Davis
\end{ekey}
We can make ‘$\exists$x Sx’ true by including something in the extension of ‘S’, and we can make ‘$\forall$x Sx’ false by leaving something out of the extension of ‘S’. For concreteness, let’s say:

\begin{ekey}\item[domain]  Ornette Coleman, Miles Davis
\item[Sx] x plays saxophone
\end{ekey}
Now ‘$\exists$x Sx’ is true, because ‘Sx’ is true of Ornette Coleman. Slightly more precisely, extend our interpretation by allowing ‘c’ to name Ornette Coleman. ‘Sc’ is true in this extended interpretation, so ‘$\exists$x Sx’ was true in the original interpretation. Similarly, ‘$\forall$x Sx’ is false, because ‘Sx’ is false of Miles Davis. Slightly more precisely, extend our interpretation by allowing ‘d’ to name Miles Davis, and ‘Sd’ is false in this extended interpretation, so ‘$\forall$x Sx’ was false in the original interpretation. We have provided a counter-interpretation to the claim that ‘$\forall$x Sx’ and ‘$\exists$x Sx’ are logically equivalent. Here is the condition put concisely:

To show that A and B are not logically equivalent, it suffices to find an interpretation where one is true and the other is false. 
\subsection{Validity, entailment and satisfiability}

To test for validity, entailment, or satisfiability, we typically need to produce interpretations that determine the truth value of several sentences simultaneously. Consider the following argument in QL:
\begin{center}
$\exists$x (Gx\eif Ga) \therefore $\exists$x Gx\eif Ga
\end{center}
To show that this is invalid, we must make the premise true and the conclusion false. The conclusion is a conditional, so to make it false, the antecedent must be true and the consequent must be false. Clearly, our domain must contain two objects. Let’s try:

\begin{ekey}\item[domain]  Karl Marx, Ludwig von Mises
\item[Gx] x hated communism
\item[a] Karl Marx
\end{ekey}
Given that Marx wrote The Communist Manifesto, ‘Ga’ is plainly false in this interpretation. But von Mises famously hated communism, so ‘$\exists$x Gx’ is true in this interpretation. Hence ‘$\exists$x Gx \eif Ga’ is false, as required.

Does this interpretation make the premise true? Yes it does! Note that ‘Ga\eif Ga’ is true. (Indeed, it is a tautology.) But then certainly ‘$\exists$x (Gx\eif Ga)’ is true, so the premise is true, and the conclusion is false, in this interpretation. The argument is therefore invalid.

In passing, note that we have also shown that ‘$\exists$x (Gx\eif Ga)’ does not entail ‘$\exists$x Gx\eif Ga’, i.e., that $\exists$x (Gx\eif Ga) $\nvDash$ $\exists$xGx\eif Ga. Equally, we have shown that the sentences ‘$\exists$x (Gx\eif Ga)’ and ‘\enot ($\exists$xGx\eif Ga)’ are jointly satisfiable.

Let’s consider a second example. Consider:

$\forall$x$\exists$y Lxy \therefore $\exists$y$\forall$x Lxy

Again, we want to show that this is invalid. To do this, we must make the premises true and the conclusion false. Here is a suggestion:

\begin{ekey}\item[domain]  Canadian citizens currently in a domestic partnership with another Canadian citizen
\item[Lxy] x is in a domestic partnership with y
\end{ekey}
The premise is clearly true on this interpretation. Anyone in the domain is a Canadian citizen in a domestic partnership with some other Canadian citizen. That other citizen will also, then, be in the domain. So for everyone in the domain, there will be someone (else) in the domain with whom they are in a domestic partnership. Hence ‘$\forall$x$\exists$y Lxy’ is true. However, the conclusion is clearly false, for that would require that there is some single person who is in a domestic partnership with everyone in the domain, and there is no such person, so the argument is invalid. We observe immediately that the sentences ‘$\forall$x$\exists$y Lxy’ and ‘\enot $\exists$y$\forall$x Lxy’ are jointly satisfiable and that ‘$\forall$x$\exists$y Lxy’ does not entail ‘$\exists$y$\forall$x Lxy’.

For our third example, we’ll mix things up a bit. Previously, we described how we can present some interpretations using diagrams. For example:

\begin{center}
	\begin{tikzpicture}[modal]
		\node[world] (w1) {1};
		\node[world] (w2) [right=of w1]{2};
		\node[world] (w3) [below=of w2]{3};
		\path[->] (w1) edge[reflexive above] (w1);
		\path[->] (w1) edge (w2);
		\path[->] (w2) edge (w3);
		\path[->] (w1) edge (w3);
	\end{tikzpicture}
\end{center}

Using the conventions employed previously, the domain of this interpretation is the first three positive whole numbers, and ‘Rxy’ is true of x and y just in case there is an arrow from x to y in our diagram. Here are some sentences that the interpretation makes true:
\begin{earg}
\item[]$\forall$x$\exists$y Ryx
\item[]$\exists$x$\forall$y Rxy (loook at 1)
\item[]$\exists$x$\forall$y(Ryx\eiff Rxx)  (look at 1)
\item[]$\exists$x$\exists$y$\exists$z( (\enot Rxx\eand Rxy)\eand Rzx) (look at 2)
\item[]$\exists$x$\forall$y \enot Rxy (look at 3)
\item[]$\exists$x ($\exists$y Ryx\eand \enot $\exists$y Rxy) (look at 3)
\end{earg}
This immediately shows that all of the preceding six sentences are jointly satisfiable. We can use this observation to generate invalid arguments, e.g.:
\begin{earg}
\item[]$\forall$x$\exists$y Ryx,$\exists$x$\forall$y Rxy \therefore $\forall$x$\exists$y Rxy
\item[]$\exists$x$\forall$y Rxy,$\exists$x$\forall$y\enot Rxy \therefore \enot $\exists$x$\exists$y$\exists$z(\enot y=z\eand (Rxy\eand Rzx))
\item[]and many more besides.
\end{earg}
\factoidbox{
If some interpretation makes all of $A_1,A_2,\ldots,A_n$ true and C is false, then:
\begin{earg}
\item[]$A_1,A_2,\ldots,A_n$\therefore C is invalid
\item[]$A_1,A_2,\ldots,A_n$ $\nvDash$ C
\item[]$A_1,A_2,\ldots,A_n$,\enot C are jointly satisfiable.
\end{earg}
}

An interpretation which refutes a claim—to logical truth, say, or to entailment—is called a \gls{counter-interpretation}, or a \gls{countermodel}.


\newglossaryentry{counter-interpretation}
{
name={counter-interpretation},
text={counter-interpreation},
description={An interpretation which disproves the validity of an argument in QL}
}

\newglossaryentry{countermodel}
{
name={countermodel},
text={countermodel},
description={A diagram or model which is used to represent a counter-interpretation in QL or used to demonstrate the invalidity of an argument in ML}
}


We’ll close this section, though, with a caution about the relationship between (in)validity and (non)entailment. Recall QL’s limitations: it is is an extensional language; it ignores issues of vagueness; and it cannot handle cases of validity for ‘special reasons’. To take one illustration of these issues, consider this natural-language argument:
\begin{center}
Every fox is cute. \therefore All vixens are cute.
\end{center}
This is valid: necessarily every vixen is a fox, so it is impossible for the premise to be true and the conclusion false. Now, we might sensibly symbolize the argument as follows:
\begin{center}
$\forall$x (Fx\eif Cx) \therefore $\forall$x (Vx\eif Cx)
\end{center}
However, it is easy to find counter-models which show that $\forall$x (Fx\eif Cx) $\nvDash$ $\forall$x (Vx\eif Cx). (As a fun exercise, try to find one.) So, it would be wrong to infer that the English argument is invalid, just because there is a counter-model to the relevant QL-entailment.

The general moral is this. If you want to infer from the absence of an entailment in QL to the invalidity of some English argument, then you need to argue that nothing important is lost in the way you have symbolized the English argument.

\practiceproblems

\problempart
\label{pr.Contingent}
Show that each of the following is neither a validity nor a contradiction:
\begin{enumerate}
\item \leftsolutions\ $\atom{D}{a}  \eand \atom{D}{b}$
\item \leftsolutions\ $\exists x\, \atom{T}{xh}$
\item \leftsolutions\ $\atom{P}{m}  \eand \enot\forall x\, \atom{P}{x}$
\item $\forall z \atom{J}{z} \eiff \exists y\, \atom{J}{y}$
\item $\forall x (\atom{W}{xmn} \eor \exists y\atom{L}{xy})$
\item $\exists x (\atom{G}{x} \eif \forall y\, \atom{M}{y})$
\item $\exists x (x = h \eand x = i)$
\end{enumerate}

\solutions
\problempart
\label{pr.NotEquiv}
Show that the following pairs of sentences are not logically equivalent.
\begin{enumerate}
\item $\atom{J}{a} $,  $\atom{K}{a}$
\item $\exists x\, \atom{J}{x}$,  $\atom{J}{m}$
\item $\forall x\, \atom{R}{xx}$, $\exists x\, \atom{R}{xx}$
\item $\exists x\, \atom{P}{x} \eif \atom{Q}{c}$, $\exists x (\atom{P}{x} \eif \atom{Q}{c})$
\item $\forall x(\atom{P}{x} \eif \enot \atom{Q}{x})$, $\exists x(\atom{P}{x} \eand \enot \atom{Q}{x})$
\item $\exists x(\atom{P}{x} \eand \atom{Q}{x})$, $\exists x(\atom{P}{x} \eif \atom{Q}{x})$
\item $\forall x(\atom{P}{x}\eif \atom{Q}{x})$, $\forall x(\atom{P}{x} \eand \atom{Q}{x})$
\item $\forall x\exists y\, \atom{R}{xy}$, $\exists x\forall y\, \atom{R}{xy}$
\item $\forall x\exists y\, \atom{R}{xy}$, $\forall x\exists y\, \atom{R}{yx}$
\end{enumerate}

\problempart
Show that the following sentences are jointly satisfiable:
\begin{enumerate}
\item  $\atom{M}{a}, \enot \atom{N}{a}, \atom{P}{a}, \enot \atom{Q}{a}$
\item $\atom{L}{ee}, \atom{L}{eg}, \enot \atom{L}{ge}, \enot \atom{L}{gg}$
\item $\enot (\atom{M}{a} \eand \exists x\, \atom{A}{x}), \atom{M}{a} \eor \atom{F}{a}, \forall x(\atom{F}{x} \eif \atom{A}{x})$
\item $\atom{M}{a} \eor \atom{M}{b}, \atom{M}{a} \eif \forall x \enot \atom{M}{x}$
\item $\forall y\, \atom{G}{y}, \forall x (\atom{G}{x} \eif \atom{H}{x}), \exists y \enot \atom{I}{y}$
\item $\exists x(\atom{B}{x} \eor \atom{A}{x}), \forall x \enot \atom{C}{x}, \forall x\bigl[(\atom{A}{x} \eand \atom{B}{x}) \eif \atom{C}{x}\bigr]$
\item $\exists x\, \atom{X}{x}, \exists x\, \atom{Y}{x}, \forall x(\atom{X}{x} \eiff \enot \atom{Y}{x})$
\item $\forall x(\atom{P}{x} \eor \atom{Q}{x}), \exists x\enot(\atom{Q}{x} \eand \atom{P}{x})$
\item $\exists z(\atom{N}{z} \eand \atom{O}{zz}), \forall x\forall y(\atom{O}{xy} \eif \atom{O}{yx})$
\item $\enot \exists x \forall y\, \atom{R}{xy}, \forall x \exists y\, \atom{R}{xy}$
\item $\enot \atom{R}{aa}$, $\forall x (x=a \eor \atom{R}{xa})$
\item $\forall x\forall y\forall z[(x=y \eor y=z )\eor x=z]$, $\exists x\exists y\ \enot x= y$
\item $\exists x\exists y((\atom{Z}{x} \eand \atom{Z}{y} )\eand x=y)$, $\enot \atom{Z}{d}$, $d=e$
\end{enumerate}

\problempart
Show that the following arguments are invalid:
\begin{enumerate}
\item $\forall x(\atom{A}{x} \eif \atom{B}{x}) \therefore \exists x\, \atom{B}{x}$
\item $\forall x(\atom{R}{x} \eif \atom{D}{x}), \forall x(\atom{R}{x} \eif \atom{F}{x}) \therefore \exists x(\atom{D}{x} \eand \atom{F}{x})$
\item $\exists x(\atom{P}{x}\eif \atom{Q}{x}) \therefore \exists x\, \atom{P}{x}$
\item $\atom{N}{a} \eand \atom{N}{b} \eand \atom{N}{c} \therefore \forall x\, \atom{N}{x}$
\item $\atom{R}{d,e}, \exists x\, \atom{R}{xd} \therefore \atom{R}{ed}$
\item $\exists x(\atom{E}{x} \eand \atom{F}{x}), \exists x\, \atom{F}{x} \eif \exists x\, \atom{G}{x} \therefore \exists x(\atom{E}{x} \eand \atom{G}{x})$
\item $\forall x\, \atom{O}{xc}, \forall x\, \atom{O}{cx} \therefore \forall x\, \atom{O}{xx}$
\item $\exists x(\atom{J}{x} \eand \atom{K}{x}), \exists x \enot \atom{K}{x}, \exists x \enot \atom{J}{x} \therefore \exists x(\enot \atom{J}{x} \eand \enot \atom{K}{x})$
\item $\atom{L}{a,b} \eif \forall x\, \atom{L}{xb}, \exists x\, \atom{L}{x,b} \therefore \atom{L}{b,b}$
\item $\forall x(\atom{D}{x} \eif \exists y\, \atom{T}{yx}) \therefore \exists y \exists z\ \enot y= z$
\end{enumerate}



\section{Part 23.3: Reasoning about All Interpretations}
\label{allinterp}
\subsection{Tautologies and contradictions}

We can show that a sentence is not a tautology just by providing one carefully specified interpretation: an interpretation in which the sentence is false. To show that something is a tautology, on the other hand, it would not be enough to construct ten, one hundred, or even a thousand interpretations in which the sentence is true. A sentence is only a tautology if it is true in every interpretation, and there are infinitely many interpretations. We need to reason about all of them, and we cannot do this by dealing with them one by one!

Sometimes, we can reason about all interpretations fairly easily. For example, we can offer a relatively simple argument that ‘Raa\eor \enot Raa’ is a tautology:

\factoidbox{
Any relevant interpretation will give ‘Raa’ a truth value. If ‘Raa’ is true in an interpretation, then ‘Raa\eor \enot Raa’ is true in that interpretation. If ‘Raa’ is false in an interpretation, then \enot Raa is true, and so ‘Raa\eor \enot Raa’ is true in that interpretation. These are the only alternatives. So ‘Raa\eor \enot Raa’ is true in every interpretation. Therefore, it is a tautology.}

This argument is valid, of course, and its conclusion is true. However, it is not an argument in QL. Rather, it is an argument in English about QL: it is an argument in the metalanguage.

Note another feature of the argument. Since the sentence in question contained no quantifiers, we did not need to think about how to interpret ‘a’ and ‘R’; the point was just that, however we interpreted them, ‘Raa’ would have some truth value or other. (We could ultimately have given the same argument concerning PL sentences; using ‘R' rather than ‘Raa'.)

Let’s have another example. The sentence ‘$\forall$x (Rxx\eor \enot Rxx)’ should obviously be a tautology. However, saying precisely why is quite tricky. We cannot say that ‘Rxx\eor \enot Rxx’ is true in every interpretation, since ‘Rxx\eor \enot Rxx’ is not even a sentence of QL (remember that ‘x’ is a variable, not a name). Instead, we should say something like this:
\factoidbox{
Consider some arbitrary interpretation. $\forall$x (Rxx\eor \enot Rxx) is true in our interpretation iff Rxx\eor \enot Rxx is satisfied by every object of its domain. Consider some arbitrary member of the domain, which, for convenience, we will call Fred. Either Fred satisfies Rxx or it does not. If Fred satisfies ‘Rxx’, then Fred also satisfies ‘Rxx\eor \enot Rxx’. If Fred does not satisfy ‘Rxx’, it does satisfy ‘\enot Rxx’ and so also ‘Rxx\eor \enot Rxx’. So either way, Fred satisfies ‘Rxx\eor \enot Rxx’. Since there was nothing special about Fred—we might have chosen any object—we see that every object in the domain satisfies ‘Rxx\eor \enot Rxx’. So ‘$\forall$x (Rxx\eor \enot Rxx)’ is true in our interpretation. But we chose our interpretation arbitrarily, so ‘$\forall$x (Rxx\eor \enot Rxx)’ is true in every interpretation. It is therefore a tautology.}

This is quite longwinded, but, as things stand, there is no alternative. This should seem very similar to the argument made about ‘Raa', and it is. It is the same general method, the difference is that we needed to talk about some generic member of the domain and give them some completely arbitrary name. Since we did not rely on anything about a particular member of the domain, we can generalize it to all of them. So, in order to show that a sentence is a tautology, we must reason about all interpretations.

\subsection{Other Cases}

Similar points hold of other cases too. Thus, we must reason about all interpretations if we want to show:
\factoidbox{
\begin{ebullet}
	\item[\textbullet]that a sentence is a contradiction; for this requires that it is false in every interpretation.
	\item[\textbullet]that two sentences are logically equivalent; for this requires that they have the same truth value in every interpretation.
	\item[\textbullet]that some sentences are jointly unsatisfiable; for this requires that there is no interpretation in which all of those sentences are true together; i.e. that, in every interpretation, at least one of those sentences is false.
	\item[\textbullet]that an argument is valid; for this requires that the conclusion is true in every interpretation where the premises are true.
	\item[\textbullet]that some sentences entail another sentence.
\end{ebullet}}

The problem is that, with the tools available to you so far, reasoning about all interpretations is a serious challenge! For a final example, here is a perfectly obvious entailment:
\begin{center}
$\forall$x (Hx\eand Jx) $\vDash$  $\forall$x Hx
\end{center}
After all, if everything is both H and J , then everything is H . But we can only establish the entailment by considering what must be true in every interpretation in which the premise is true. To show this, we would have to reason as follows:
\factoidbox{
Consider an arbitrary interpretation in which ‘$\forall$x (Hx\eand Jx)’ is true. It follows that ‘Hx\eand Jx’ is satisfied by every object in this interpretation. ‘Hx’ will, then, also be satisfied by every object. So it must be that ‘$\forall$x Hx’ is true in the interpretation. We’ve assumed nothing about the interpretation except that it was one in which ‘$\forall$x (Hx\eand Jx)’ is true. So any interpretation in which ‘$\forall$x (Hx\eand Jx)’ is true is one in which ‘$\forall$x Hx’ is true.
}
Even for a simple entailment like this one, the reasoning is somewhat complicated. For more complicated entailments, the reasoning can be extremely torturous. 

The following table summarizes whether a single interpretation or counter-interpretation suffices, or whether we must reason about all interpretations.\\
\begin{tabular}{l|ll}
&Yes&No\\
\hline
Tautology?&All Interpretations&One Counter-interpretation\\
Contradiction?&All Interpretations&One Counter-interpretation\\
Equivalent?&All Interpretations&One Counter-interpretation\\
Satisfiable?&One Interpretation&All Interpretations\\
Valid?&All Interpretations&One Counter-interpretation\\
Entailment?&All Interpretations&One Counter-interpretation\\
\end{tabular}

You might want to compare this table with the table at the end of the similar content for PL, they are very similar. The key difference resides in the fact that PL concerns truth tables, whereas QL concerns interpretations. This difference is deeply important, since each truth-table only ever has finitely many lines, so that a complete truth table is a relatively tractable object. By contrast, there are infinitely many interpretations for any given sentence(s), so that reasoning about all interpretations can be a deeply tricky business. To avoid this for arguments, one can use a natural deduction system for QL to prove the validity and entailment. We will be going over this next. So, to show that an argument is valid in QL, you need to make a proof and to show that it is invalid, you need to make a counter-interpretation.  

\newglossaryentry{interpretation}{
  name = {interpretation},
  description = {A specification of a \gls{domain} together with the objects the \glspl{name} pick out and which objects the \glspl{predicate} are true of}
}

\newglossaryentry{substitution instance}{
  name = substitution instance,
  description = {The result of replacing every free occurrence of a \gls{variable} in a \gls{formula} with a \gls{name}}
}

\newglossaryentry{tautology (in QL)}
{
name=tautology (in QL),
description={A \gls{sentence of QL} that is true in every \gls{interpretation}}
}

\newglossaryentry{contradiction of QL}
{
  name=contradiction (of QL),
  text=contradiction,
description={A \gls{sentence of QL} that is false in every \gls{interpretation}}
}

\newglossaryentry{valid in QL}
{
  name=validity of arguments (in QL),
  text = valid,
description={A property held by arguments; an argument is valid if and only if no \gls{interpretation} makes all premises true and the conclusion false}
}

\newglossaryentry{equivalent in QL}
{
  name=equivalence (in QL),
  text = equivalent,
description={A property held by pairs of \glspl{sentence of QL} if and only if the sentences have the same truth value in every \gls{interpretation}}
}

\newglossaryentry{satisfiable in QL}
{
  name=satisfiability (in QL),
  text=jointly satisfiable,
description={A property held by \glspl{sentence of QL} if and only if some \gls{interpretation} makes all the sentences true}
}

